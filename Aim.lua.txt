local SilentAimModule = {}

local VSkillModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/jaanu91/Ip/refs/heads/main/Uo"))()

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local Character = player.Character or player.CharacterAdded:Wait()
local UserInputService = game:GetService("UserInputService")  
local RunService = game:GetService("RunService")
local camera = workspace.CurrentCamera
local RS = game:GetService("ReplicatedStorage")
local commE = RS:WaitForChild("Remotes"):WaitForChild("CommE")
local MouseModule = RS:FindFirstChild("Mouse")

local Services = setmetatable({}, {
    __index = function(self, serviceName)
        local good, service = pcall(game.GetService, game, serviceName);
        if (good) then
            self[serviceName] = service
            return service;
        end
    end
});

local SilentAimPlayersEnabled = false
local SilentAimNPCsEnabled = false
local UserWantsplayerAim = false
local UserWantsNPCAim = false
local PredictionEnabled = true
local HighlightEnabled = false 
local AutoKen = false
local ZSkillorM1= false
local autoKenRunning = false

local renderConnection = nil
local currentTool = nil
local playersaimbot = nil
local PlayersPosition = nil
local NPCaimbot = nil
local NPCPosition = nil
local currentHighlight = nil
local currentTargetType = nil
local Selectedplayer = nil
-- PIN / IGNORE SYSTEM
local PinnedPlayer = nil        -- Player object
local IgnoredPlayers = {}       -- [playerName] = true
local MiniPlayerState = nil
local MiniNpcState = nil
local MiniPlayerCreated = false
local MiniNpcCreated = false
local MiniPlayerGui, MiniNpcGui = nil, nil
-- TARGET INFO
local PlayerTarget = nil
local NPCTarget = nil

local characterConnections = {}
local Skills = {"X"}
local Booms = {"TAP"}

local PredictionAmount = 1
local maxRange = 800
local LOW_HP_PRIORITY_DISTANCE = 150

local BasePrediction = 0.17      -- Prediction g·ªëc
local MinPrediction = 0.08
local MaxPrediction = 0.27

local GroundCheckDistance = 4    -- Kho·∫£ng c√°ch t√≠nh l√† "g·∫ßn m·∫∑t ƒë·∫•t"

local function isNearGround(hrp)
	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = {hrp.Parent}
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist

	local rayResult = Workspace:Raycast(
		hrp.Position,
		Vector3.new(0, -GroundCheckDistance, 0),
		rayParams
	)

	return rayResult ~= nil
end

local MAX_AIM_DISTANCE = 800

local function isInAimDistance(plr)
	if not plr or not plr.Character then return false end

	local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
	local myHRP = player.Character and player.Character:FindFirstChild("HumanoidRootPart")

	if not hrp or not myHRP then return false end

	return (hrp.Position - myHRP.Position).Magnitude <= MAX_AIM_DISTANCE
end

local function getDynamicPrediction(hrp)
	local camPos = Camera.CFrame.Position
	local distance = (hrp.Position - camPos).Magnitude

	-- Scale prediction theo kho·∫£ng c√°ch
	local prediction = BasePrediction + (distance / 1000)

	return math.clamp(prediction, MinPrediction, MaxPrediction)
end

--------------------------------------------------
-- PIN / IGNORE FUNCTIONS
--------------------------------------------------
local function togglePinPlayer(plr)
	if PinnedPlayer == plr then
		PinnedPlayer = nil
	else
		PinnedPlayer = plr
	end
	Selectedplayer = nil
	refreshPlayerLists()
end

local function toggleIgnorePlayer(name)
	IgnoredPlayers[name] = not IgnoredPlayers[name]

	if PinnedPlayer and PinnedPlayer.Name == name then
		PinnedPlayer = nil
	end

	Selectedplayer = nil
	refreshPlayerLists()
end

local function getHRP(model)
	if not model or not model:FindFirstChild("HumanoidRootPart") then return nil end
	return model.HumanoidRootPart
end

local function clearConnections()
	for _, conn in ipairs(characterConnections) do
		pcall(function() conn:Disconnect() end)
	end
	characterConnections = {}
end

local function getPredictedPosition(hrp)
	if not hrp then return nil end

	local humanoid = hrp.Parent:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		return hrp.Position
	end

	if not PredictionEnabled or humanoid.WalkSpeed < 5 then
		return hrp.Position
	end

	local velocity = hrp.Velocity
	local predictionAmount = getDynamicPrediction(hrp)

	-- N·∫øu g·∫ßn m·∫∑t ƒë·∫•t ‚Üí kh√¥ng ƒëo√°n r∆°i xu·ªëng
	if isNearGround(hrp) then
		if velocity.Y < 0 then
			velocity = Vector3.new(velocity.X, 0, velocity.Z)
		end
	end

	return hrp.Position + (velocity * predictionAmount)
end

local function createMiniToggle(name, position, stateVarRef, realVarSetter)
	local playerGui = player:WaitForChild("PlayerGui")
    if playerGui:FindFirstChild(name .. "MiniToggleGuiS") then
        playerGui[name .. "MiniToggleGuiS"]:Destroy()
    end
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = name .. "MiniToggleGuiS"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = player:WaitForChild("PlayerGui")

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 70, 0, 40) 
    button.Position = position
    button.Text = name .. (stateVarRef.value and " ON" or " OFF")
    button.TextScaled = true
    button.TextWrapped = false
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.BorderSizePixel = 0
    button.Parent = screenGui

    local uicorner = Instance.new("UICorner")
    uicorner.CornerRadius = UDim.new(0, 8)
    uicorner.Parent = button

    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 100, 50)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 200, 50))
    }
    gradient.Rotation = 45
    gradient.Parent = button

    local function updateUI(state)
        button.Text = name .. (state and " ON" or " OFF")
        gradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, state and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(255, 100, 50)),
            ColorSequenceKeypoint.new(1, state and Color3.fromRGB(50, 255, 50) or Color3.fromRGB(255, 200, 50))
        }
    end

    button.MouseButton1Click:Connect(function()
        stateVarRef.value = not stateVarRef.value
        realVarSetter(stateVarRef.value)
        updateUI(stateVarRef.value)
    end)

    -- =========================
    -- Dragging functionality
    -- =========================
    local dragging = false
    local dragStart = nil
    local startPos = nil

    local function onInputBegan(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = button.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end

    local function onInputChanged(input)
        if dragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
            local delta = input.Position - dragStart
            button.Position = UDim2.new(
                0,
                math.clamp(startPos.X.Offset + delta.X, 0, camera.ViewportSize.X - button.AbsoluteSize.X),
                0,
                math.clamp(startPos.Y.Offset + delta.Y, 0, camera.ViewportSize.Y - button.AbsoluteSize.Y)
            )
        end
    end

    button.InputBegan:Connect(onInputBegan)
    button.InputChanged:Connect(onInputChanged)

    updateUI(stateVarRef.value)
    return screenGui
end

-- =========================
-- Team Check
-- =========================
local function isAllyWithMe(targetplayer)
	local myGui = player:FindFirstChild("PlayerGui")
	if not myGui then return false end

	local scrolling = myGui:FindFirstChild("Main")
		and myGui.Main:FindFirstChild("Allies")
		and myGui.Main.Allies:FindFirstChild("Container")
		and myGui.Main.Allies.Container:FindFirstChild("Allies")
		and myGui.Main.Allies.Container.Allies:FindFirstChild("ScrollingFrame")

	if scrolling then
		for _, frame in pairs(scrolling:GetDescendants()) do
			if frame:IsA("ImageButton") and frame.Name == targetplayer.Name then
				return true
			end
		end
	end

	return false
end

local function isEnemy(targetplayer)
	if not targetplayer or targetplayer == player then
		return false
	end

	local myTeam = player.Team
	local targetTeam = targetplayer.Team

	if myTeam and targetTeam then
		if myTeam.Name == "Pirates" and targetTeam.Name == "Marines" then
			return true
		elseif myTeam.Name == "Marines" and targetTeam.Name == "Pirates" then
			return true
		end

		if myTeam.Name == "Pirates" and targetTeam.Name == "Pirates" then
			if isAllyWithMe(targetplayer) then
				return false -- ally, not enemy
			end
			return true
		end

		if myTeam.Name == "Marines" and targetTeam.Name == "Marines" then
			return false
		end
	end

	return true
end

local function getLowestHPPlayerInRange(lpHRP, range)
    local lowest = nil
    local lowestRatio = math.huge

    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= player
        and not IgnoredPlayers[pl.Name]
        and isEnemy(pl)
        and pl.Character then

            local hrp = getHRP(pl.Character)
            local hum = pl.Character:FindFirstChildWhichIsA("Humanoid")

            if hrp and hum and hum.Health > 0 then
                local dist = (hrp.Position - lpHRP.Position).Magnitude
                if dist <= range then
                    local ratio = hum.Health / hum.MaxHealth
                    if ratio < lowestRatio then
                        lowestRatio = ratio
                        lowest = pl
                    end
                end
            end
        end
    end

    return lowest
end

local function getClosestplayer(lpHRP)
	-- ===== C√ì PIN ‚Üí ∆ØU TI√äN PIN =====
	if PinnedPlayer then
		if not IgnoredPlayers[PinnedPlayer.Name]
		and PinnedPlayer.Character then

			local hum = PinnedPlayer.Character:FindFirstChildWhichIsA("Humanoid")
			local hrp = getHRP(PinnedPlayer.Character)

			if hum and hum.Health > 0 and hrp then
				if isInAimDistance(PinnedPlayer) then
					return PinnedPlayer
				else
					-- PIN NGO√ÄI T·∫¶M ‚Üí KH√îNG AIM AI
					return nil
				end
			end
		end

		-- PIN KH√îNG H·ª¢P L·ªÜ ‚Üí HU·ª∂ PIN
		PinnedPlayer = nil
	end

	-- ===== KH√îNG PIN =====

-- üî¥ ∆ØU TI√äN LOW HP TRONG 150m
local lowHpTarget = getLowestHPPlayerInRange(lpHRP, LOW_HP_PRIORITY_DISTANCE)
if lowHpTarget and isInAimDistance(lowHpTarget) then
    return lowHpTarget
end

-- üü° KH√îNG C√ì ‚Üí AIM NG∆Ø·ªúI G·∫¶N NH·∫§T
local closest = nil
local closestDist = math.huge

for _, pl in ipairs(Players:GetPlayers()) do
    if pl ~= player
    and not IgnoredPlayers[pl.Name]
    and isEnemy(pl)
    and pl.Character then

        local hrp = getHRP(pl.Character)
        local hum = pl.Character:FindFirstChildWhichIsA("Humanoid")

        if hrp and hum and hum.Health > 0 and isInAimDistance(pl) then
            local dist = (hrp.Position - lpHRP.Position).Magnitude
            if dist < closestDist then
                closestDist = dist
                closest = pl
            end
        end
    end
end

return closest
end

local function getClosestNPC(lpHRP)
    if not lpHRP then return nil end

    local enemiesFolder = workspace:FindFirstChild("Enemies")
    if not enemiesFolder then return nil end

    local closest = nil
    local closestDist = math.huge
    for _, npc in ipairs(enemiesFolder:GetChildren()) do
        if npc:IsA("Model") then
            local hum = npc:FindFirstChildWhichIsA("Humanoid")
            local hrp = getHRP(npc)
            if hum and hum.Health > 0 and hrp then
                local dist = (hrp.Position - lpHRP.Position).Magnitude
                if dist <= maxRange and dist < closestDist then
                    closestDist = dist
                    closest = npc
                end
            end
        end
    end
    return closest
end

local function applyHighlight(targetModel, targetType)
    if not HighlightEnabled then return end
    if not targetModel then return end
    if currentHighlight and currentHighlight.Adornee == targetModel then return end

    if currentHighlight then  
        currentHighlight:Destroy()  
        currentHighlight = nil  
        currentTargetType = nil  
    end  

    local hl = Instance.new("Highlight")  
    hl.FillColor = Color3.fromRGB(255, 255, 0)  
    hl.OutlineColor = Color3.fromRGB(255, 255, 0)  
    hl.FillTransparency = 0.5  
    hl.OutlineTransparency = 0  
    hl.Adornee = targetModel  
    hl.Parent = targetModel  
    currentHighlight = hl  
    currentTargetType = targetType

    VSkillModule:CheckVSkillUsage(SilentAimModule)
end

local function clearHighlight()
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
        currentTargetType = nil
    end
end

local function isSkillReadyForTool(toolName)
    if not toolName then return false end
    local playerGui = player:FindFirstChild("PlayerGui")
    if not playerGui then return false end
    local skillsFolder = playerGui:FindFirstChild("Main") and playerGui.Main:FindFirstChild("Skills")
    if not skillsFolder then return false end
    local toolFrame = skillsFolder:FindFirstChild(toolName)
    if not toolFrame then return false end

    for _, skillKey in ipairs({"Z","X","C","V"}) do
        local skill = toolFrame:FindFirstChild(skillKey)
        if skill and skill:FindFirstChild("Cooldown") and skill.Cooldown:IsA("Frame") then
            local cooldownSize = skill.Cooldown.Size.X.Scale
            if cooldownSize == 1.0 then
                return true
            end
        end
    end
    return false
end

local function isNotDoughValidCondition()
    return (currentTool and currentTool.Name == "Dough-Dough")
end

local function isNotValidCondition()
    return (currentTool and currentTool.Name == "Lightning-Lightning")
    or (currentTool and currentTool.Name == "Portal-Portal")
end

local function isUsingYama()
    return currentTool and currentTool.Name == "Yama Sword"
end

local function startRenderLoop()
    if renderConnection then return end

    renderConnection = RunService.RenderStepped:Connect(function()
        local lpChar = player.Character
        if not lpChar then return end
        local lpHRP = lpChar:FindFirstChild("HumanoidRootPart")
        if not lpHRP then return end

        if not SilentAimPlayersEnabled and not SilentAimNPCsEnabled then
            return
        end

        local targetModel = nil
        local lookTargetPos = nil

        if SilentAimPlayersEnabled then
            local targetplayer = getClosestplayer(lpHRP)
            if targetplayer and targetplayer ~= player and targetplayer.Character then
                playersaimbot = targetplayer.Name
                PlayerTarget = targetplayer.Character
                local hrp = getHRP(targetplayer.Character)
                PlayersPosition = getPredictedPosition(hrp)
                lookTargetPos = PlayersPosition
                targetModel = targetplayer.Character
                applyHighlight(targetModel, "player")
            else
                playersaimbot, PlayersPosition = nil, nil
                PlayerTarget = nil
            end
        elseif currentTargetType == "player" then
            playersaimbot, PlayersPosition = nil, nil
            clearHighlight()
        end

        if SilentAimNPCsEnabled then  
            local closestNPC = getClosestNPC(lpHRP)  
            if closestNPC then  
                NPCaimbot = closestNPC.Name  
                NPCTarget = closestNPC
                local hrp = getHRP(closestNPC)  
                NPCPosition = getPredictedPosition(hrp)
                lookTargetPos = NPCPosition
                if not targetModel then  
                    targetModel = closestNPC  
                    applyHighlight(targetModel, "NPC")  
                end  
            else  
                NPCaimbot, NPCPosition = nil, nil  
            end
        elseif currentTargetType == "NPC" then
            NPCaimbot, NPCPosition = nil, nil  
            NPCTarget = nil
            clearHighlight()
        end
    end)
end

local function stopRenderLoop()
    if renderConnection then
        renderConnection:Disconnect()
        renderConnection = nil
    end
end

local function hookTool(tool)
    currentTool = tool
    table.insert(characterConnections, tool.AncestryChanged:Connect(function(_, parent)
        if not parent then
            currentTool = nil
        end
    end))
end

local function isValidCondition()
    return (currentTool and currentTool.Name == "Buddy Sword")
end

spawn(function()
    local ok, hookMeta = pcall(getrawmetatable, game)
    if ok and hookMeta then
        setreadonly(hookMeta, false)
        local OldHook
        OldHook = hookmetamethod(game, "__namecall", function(self, V1, V2, ...)
            local Method = (getnamecallmethod and getnamecallmethod():lower()) or ""

            if tostring(self) == "RemoteEvent" and Method == "fireserver" then

                if typeof(V1) == "Vector3" then
                    if SilentAimPlayersEnabled and PlayersPosition then
                        return OldHook(self, PlayersPosition, V2, ...)
                    elseif SilentAimNPCsEnabled and NPCPosition then
                        return OldHook(self, NPCPosition, V2, ...)
                    end
				end				
				if type(V1) == "string" and table.find(Booms, V1) then
					if ZSkillorM1 then 
	                    if SilentAimPlayersEnabled and PlayersPosition then
	                        return OldHook(self, V1, PlayersPosition, nil, ...)
	                    elseif SilentAimNPCsEnabled and NPCPosition then
	                        return OldHook(self, V1, NPCPosition, nil, ...)
	                    end
					end
				end   
            elseif Method == "invokeserver" then  
	            if isValidCondition() then
if isUsingYama() and V1 == "Z" then
            return OldHook(self, V1, V2, ...)
        end
	                if type(V1) == "string" and table.find(Skills, V1) then  
	                    if SilentAimPlayersEnabled and PlayersPosition then  
	                        return OldHook(self, V1, PlayersPosition, nil, ...)
	                    elseif SilentAimNPCsEnabled and NPCPosition then
		                    return OldHook(self, V1, NPCPosition, nil, ...)
	                    end  
	                end    
				end				
			end
            
            return OldHook(self, V1, V2, ...)
        end)
        setreadonly(hookMeta, true)
    end
end)

if not isNotValidCondition() then
	if MouseModule and typeof(MouseModule) == "Instance" then
        local ok2, okResult = pcall(function()
            return require(MouseModule)
        end)

        if ok2 and okResult then  
            if type(okResult) == "table" then  
                Mouse = okResult  
            else  
                Mouse = nil  
            end  
        else  
            Mouse = nil  
        end  

        if Mouse then  
            local Character = player.Character or player.CharacterAdded:Wait()  
            local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")  

            if RootPart then  
                pcall(function()  
                    if type(Mouse) == "table" then  
                        Mouse.Hit = CFrame.new(RootPart.Position)  
                        Mouse.Target = RootPart  
                    end  
                end)  
            else  
                task.spawn(function()  
                    local Character = player.Character or player.CharacterAdded:Wait()  
                    local RootPart = Character:WaitForChild("HumanoidRootPart")  
                    pcall(function()  
                        if type(Mouse) == "table" then  
                            Mouse.Hit = CFrame.new(RootPart.Position)  
                            Mouse.Target = RootPart  
                        end  
                    end)  
                end)  
            end  
        end  

        RunService.Heartbeat:Connect(function()  	        
		    if not ZSkillorM1 or (not SilentAimPlayersEnabled and not SilentAimNPCsEnabled) then
		        return
		    end
		
            if Mouse and ZSkillorM1 and (SilentAimPlayersEnabled or SilentAimNPCsEnabled) then 
                local targetCFrame = nil  

                if PlayersPosition then  
                    targetCFrame = CFrame.new(PlayersPosition)  
                elseif NPCPosition then  
                    targetCFrame = CFrame.new(NPCPosition)  
                end  

                if targetCFrame then  
                    pcall(function()  
                        if type(Mouse) == "table" then  
                            Mouse.Hit = targetCFrame  
                            Mouse.Target = nil  
                        end  
                    end)  

                    if MouseModule then  
                        local ok, MouseData = pcall(require, MouseModule)  
                        if ok and type(MouseData) == "table" then  
                            MouseData.Hit = targetCFrame  
                            MouseData.Target = nil  
                        end  
                    end  
                end  
            end  
        end)
    end
end

local HasTag = function(tagName)
  local char = player.Character
  if (not char) then return false; end
  return Services.CollectionService:HasTag(char, tagName);
end

local function startAutoKenLoop()
    if autoKenRunning then return end
    autoKenRunning = true

    task.spawn(function()
        while AutoKen do
            task.wait(0.1)

            if HasTag("Ken") then
                local playerGui = player:FindFirstChild("PlayerGui")
                if playerGui then
                    local kenButton = playerGui:FindFirstChild("MobileContextButtons")
                    and playerGui.MobileContextButtons.ContextButtonFrame:FindFirstChild("BoundActionKen")

                    if kenButton and kenButton:GetAttribute("Selected") ~= true then
                        kenButton:SetAttribute("Selected", true)
                    end
                end

                local observationManager = getrenv()._G.OM
                if observationManager and not observationManager.active then
                    observationManager.radius = 0
                    observationManager:setActive(true)
                    commE:FireServer("Ken", true)
                end
            end
        end
        autoKenRunning = false
    end)
end

local function onCharacterAdded(char)
    clearConnections()

    for _, child in ipairs(char:GetChildren()) do
        if child:IsA("Tool") then
            hookTool(child)
        end
    end

    table.insert(characterConnections, char.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then hookTool(child) end
    end))

    table.insert(characterConnections, char.ChildRemoved:Connect(function(child)
        if child == currentTool then
            currentTool = nil
        end
    end))
end

player.CharacterAdded:Connect(onCharacterAdded)
if player.Character then onCharacterAdded(player.Character) end

function SilentAimModule:SetAutoKen(state)
    AutoKen = state

    if state then
        startAutoKenLoop()
    end
end

function SilentAimModule:SetZSkillorM1(state)
    ZSkillorM1 = state
end

function SilentAimModule:Pause()
	SilentAimPlayersEnabled = false
	SilentAimNPCsEnabled = false
end

function SilentAimModule:Restore()
	SilentAimPlayersEnabled = UserWantsplayerAim
	SilentAimNPCsEnabled = UserWantsNPCAim
end

function SilentAimModule:IsplayerAimEnabled()
    return SilentAimPlayersEnabled
end

function SilentAimModule:IsNPCAimEnabled()
    return SilentAimNPCsEnabled
end

function SilentAimModule:SetDistanceLimit(num)
	if typeof(num) == "number" then
		maxRange = num
	end
end

function SilentAimModule:SetSelectedPlayer(playerName)
	if not playerName or playerName == "" then
		Selectedplayer = nil
		return
	end

	local found = Players:FindFirstChild(playerName)
	if found then
		Selectedplayer = found
	end
end

function SilentAimModule:GetSelectedPlayer()
	return Selectedplayer and Selectedplayer.Name or "None"
end

function SilentAimModule:SetPrediction(state)
	PredictionEnabled = state
end

function SilentAimModule:SetHighlight(state)
    HighlightEnabled = state
    if not state then
        clearHighlight()
    end
end

function SilentAimModule:IsHighlightEnabled()
    return HighlightEnabled
end

function SilentAimModule:SetPredictionAmount(num)
	if typeof(num) == "number" then
		PredictionAmount = num
	end
end

function SilentAimModule:SetPlayerSilentAim(state)
    UserWantsplayerAim = state
    SilentAimPlayersEnabled = state

    if state then
        startRenderLoop()
    else
        if not SilentAimNPCsEnabled then
            stopRenderLoop()
        end
    end
end

function SilentAimModule:SetNPCSilentAim(state)
    UserWantsNPCAim = state
    SilentAimNPCsEnabled = state

    if state then
        startRenderLoop()
    else
        if not SilentAimPlayersEnabled then
            stopRenderLoop()
        end
    end
end

local function UpdateSilentAimState()
    SilentAimPlayersEnabled = MiniPlayerState and MiniPlayerState.value or false
    SilentAimNPCsEnabled    = MiniNpcState and MiniNpcState.value or false

    UserWantsplayerAim = SilentAimPlayersEnabled
    UserWantsNPCAim    = SilentAimNPCsEnabled

    if SilentAimPlayersEnabled or SilentAimNPCsEnabled then
        startRenderLoop()
    else
        stopRenderLoop()
        clearHighlight()
    end
end

function SilentAimModule:SetMiniTogglePlayerSilentAim(state)
    if not MiniPlayerCreated and state then
        MiniPlayerState = { value = SilentAimPlayersEnabled }
        MiniPlayerGui = createMiniToggle("Player", UDim2.new(0,10,0,90), MiniPlayerState, function(val)
            MiniPlayerState.value = val
            UpdateSilentAimState()
        end)
        MiniPlayerCreated = true
    elseif MiniPlayerCreated then
        if MiniPlayerGui then
            MiniPlayerGui.Enabled = state
        end
    end
end

function SilentAimModule:SetMiniToggleNpcSilentAim(state)
    if not MiniNpcCreated and state then
        MiniNpcState = { value = SilentAimNPCsEnabled }
        MiniNpcGui = createMiniToggle("NPC", UDim2.new(0,10,0,50), MiniNpcState, function(val)
            MiniNpcState.value = val
            UpdateSilentAimState()
        end)
        MiniNpcCreated = true
    elseif MiniNpcCreated then
        if MiniNpcGui then
            MiniNpcGui.Enabled = state
        end
    end
end

--------------------------------------------------
-- PLUS BUTTON (ABOVE AIM NPC)
--------------------------------------------------
local PlusGui = Instance.new("ScreenGui", player.PlayerGui)
PlusGui.Name = "AimPlusGui"
PlusGui.ResetOnSpawn = false

local PlusBtn = Instance.new("TextButton", PlusGui)
PlusBtn.Size = UDim2.new(0,24,0,24)
PlusBtn.Position = UDim2.new(0,10,0,25)
PlusBtn.Text = "+"
PlusBtn.TextScaled = true
PlusBtn.Font = Enum.Font.GothamBold
PlusBtn.BackgroundColor3 = Color3.fromRGB(35,35,35)
PlusBtn.TextColor3 = Color3.new(1,1,1)
Instance.new("UICorner", PlusBtn).CornerRadius = UDim.new(0,6)

--------------------------------------------------
-- PLAYER LIST UI
--------------------------------------------------
local function createPlayerButton(parent, name, y, callback, state)
	local b = Instance.new("TextButton", parent)
	b.Size = UDim2.new(1,-10,0,22)
	b.Position = UDim2.new(0,5,0,y)
	b.Text = name .. (state and (" ["..state.."]") or "")
	b.TextScaled = true
	b.Font = Enum.Font.Gotham
	b.BackgroundColor3 = Color3.fromRGB(38,38,38)
	b.TextColor3 = Color3.new(1,1,1)
	Instance.new("UICorner", b).CornerRadius = UDim.new(0,6)
	b.MouseButton1Click:Connect(callback)
	return b
end

local function createSlider(text, min, max, default, posY, callback)
	local frame = Instance.new("Frame", AimMenuFrame)
	frame.Size = UDim2.new(1,-10,0,40)
	frame.Position = UDim2.new(0,5,0,posY)
	frame.BackgroundTransparency = 1

	local label = Instance.new("TextLabel", frame)
	label.Size = UDim2.new(1,0,0,16)
	label.Text = text..": "..default
	label.TextScaled = true
	label.Font = Enum.Font.Gotham
	label.TextColor3 = Color3.new(1,1,1)
	label.BackgroundTransparency = 1

	local bar = Instance.new("Frame", frame)
	bar.Position = UDim2.new(0,0,0,22)
	bar.Size = UDim2.new(1,0,0,10)
	bar.BackgroundColor3 = Color3.fromRGB(50,50,50)
	Instance.new("UICorner", bar).CornerRadius = UDim.new(1,0)

	local fill = Instance.new("Frame", bar)
	fill.Size = UDim2.new((default-min)/(max-min),0,1,0)
	fill.BackgroundColor3 = Color3.fromRGB(80,200,80)
	Instance.new("UICorner", fill).CornerRadius = UDim.new(1,0)

	local dragging = false

	bar.InputBegan:Connect(function(i)
		if i.UserInputType == Enum.UserInputType.MouseButton1
		or i.UserInputType == Enum.UserInputType.Touch then
			dragging = true
		end
	end)

	UserInputService.InputEnded:Connect(function(i)
		if i.UserInputType == Enum.UserInputType.MouseButton1
		or i.UserInputType == Enum.UserInputType.Touch then
			dragging = false
		end
	end)

	UserInputService.InputChanged:Connect(function(i)
		if dragging and (i.UserInputType == Enum.UserInputType.MouseMovement
		or i.UserInputType == Enum.UserInputType.Touch) then
			local p = math.clamp(
				(i.Position.X - bar.AbsolutePosition.X) / bar.AbsoluteSize.X,
				0,1
			)
			fill.Size = UDim2.new(p,0,1,0)
			local val = math.floor(min + (max-min)*p)
			label.Text = text..": "..val
			callback(val)
		end
	end)
end

--------------------------------------------------
-- AIM PIN MENU
--------------------------------------------------
local AimMenu = Instance.new("ScreenGui", player.PlayerGui)
AimMenu.Enabled = false
AimMenu.ResetOnSpawn = false

local AimMenuFrame = Instance.new("Frame", AimMenu)
AimMenuFrame.Size = UDim2.new(0,260,0,300)
AimMenuFrame.Position = UDim2.new(0,60,0,60)
AimMenuFrame.BackgroundColor3 = Color3.fromRGB(20,20,20)
Instance.new("UICorner", AimMenuFrame).CornerRadius = UDim.new(0,10)

local titlePin = Instance.new("TextLabel", AimMenuFrame)
titlePin.Size = UDim2.new(1,0,0,24)
titlePin.Text = "AIM PIN"
titlePin.TextColor3 = Color3.new(1,1,1)
titlePin.Font = Enum.Font.GothamBold
titlePin.TextScaled = true
titlePin.BackgroundTransparency = 1

local searchBox = Instance.new("TextBox", AimMenuFrame)
searchBox.Size = UDim2.new(1,-10,0,26)
searchBox.Position = UDim2.new(0,5,0,26)
searchBox.PlaceholderText = "Search player..."
searchBox.Text = ""
searchBox.TextScaled = true
searchBox.Font = Enum.Font.Gotham
searchBox.BackgroundColor3 = Color3.fromRGB(30,30,30)
searchBox.TextColor3 = Color3.new(1,1,1)
Instance.new("UICorner", searchBox).CornerRadius = UDim.new(0,6)

local pinList = Instance.new("ScrollingFrame", AimMenuFrame)
pinList.Position = UDim2.new(0,5,0,60)
pinList.Size = UDim2.new(1,-10,0,96)
pinList.CanvasSize = UDim2.new(0,0,0,0)
pinList.ScrollBarImageTransparency = 0.5
pinList.BackgroundTransparency = 1

local titleIgnore = Instance.new("TextLabel", AimMenuFrame)
titleIgnore.Position = UDim2.new(0,0,0,175)
titleIgnore.Size = UDim2.new(1,0,0,22)
titleIgnore.Text = "IGNORE PLAYER"
titleIgnore.TextColor3 = Color3.fromRGB(200,200,200)
titleIgnore.Font = Enum.Font.GothamBold
titleIgnore.TextScaled = true
titleIgnore.BackgroundTransparency = 1

local ignoreList = Instance.new("ScrollingFrame", AimMenuFrame)
ignoreList.Position = UDim2.new(0,5,0,200)
ignoreList.Size = UDim2.new(1,-10,0,96)
ignoreList.CanvasSize = UDim2.new(0,0,0,0)
ignoreList.ScrollBarImageTransparency = 0.5
ignoreList.BackgroundTransparency = 1

refreshPlayerLists = function()
	for _, v in ipairs(pinList:GetChildren()) do
		if v:IsA("TextButton") then v:Destroy() end
	end
	for _, v in ipairs(ignoreList:GetChildren()) do
		if v:IsA("TextButton") then v:Destroy() end
	end

	local pinY, ignoreY = 0, 0
	local filter = string.lower(searchBox.Text)

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= player and string.find(string.lower(plr.Name), filter, 1, true) then
			
			-- PIN
			local state = (PinnedPlayer == plr and "PIN") or nil
			local btn = createPlayerButton(pinList, plr.Name, pinY, function()
				togglePinPlayer(plr)
			end, state)

			if PinnedPlayer == plr then
				btn.BackgroundColor3 = Color3.fromRGB(60,180,60)
			end
			pinY += 24

			-- IGNORE
			local state2 = IgnoredPlayers[plr.Name] and "IGN"
			local btn2 = createPlayerButton(ignoreList, plr.Name, ignoreY, function()
				toggleIgnorePlayer(plr.Name)
			end, state2)

			if IgnoredPlayers[plr.Name] then
				btn2.BackgroundColor3 = Color3.fromRGB(180,60,60)
			end
			ignoreY += 24
		end
	end

	pinList.CanvasSize = UDim2.new(0,0,0,pinY)
	ignoreList.CanvasSize = UDim2.new(0,0,0,ignoreY)
end

AimMenuFrame.Size = UDim2.new(0,260,0,400)

searchBox:GetPropertyChangedSignal("Text"):Connect(refreshPlayerLists)

PlusBtn.MouseButton1Click:Connect(function()
refreshPlayerLists()
AimMenu.Enabled = not AimMenu.Enabled
if AimMenu.Enabled then
		refreshPlayerLists()
	end
end)


--------------------------------------------------
-- üéØ TARGET INFO UI
--------------------------------------------------
local gui = Instance.new("ScreenGui", player.PlayerGui)
gui.Name = "TargetInfoUI"
gui.ResetOnSpawn = false

local TargetInfoFrame = Instance.new("Frame", gui)
TargetInfoFrame.Size = UDim2.new(0.26,0,0.095,0)
TargetInfoFrame.Position = UDim2.new(0.5,0,0.05,0)
TargetInfoFrame.AnchorPoint = Vector2.new(0.5,0)
TargetInfoFrame.BackgroundTransparency = 1
TargetInfoFrame.Visible = false

local nameLbl = Instance.new("TextLabel", TargetInfoFrame)
nameLbl.Size = UDim2.new(1,0,0.4,0)
nameLbl.BackgroundTransparency = 1
nameLbl.TextScaled = true
nameLbl.Font = Enum.Font.GothamBold
nameLbl.TextColor3 = Color3.new(1,1,1)

local distLbl = Instance.new("TextLabel", TargetInfoFrame)
distLbl.Size = UDim2.new(1,0,0.25,0)
distLbl.Position = UDim2.new(0,0,0.4,0)
distLbl.BackgroundTransparency = 1
distLbl.TextScaled = true
distLbl.Font = Enum.Font.Gotham
distLbl.TextColor3 = Color3.fromRGB(200,200,200)

local hpBg = Instance.new("Frame", TargetInfoFrame)
hpBg.Size = UDim2.new(1,0,0.2,0)
hpBg.Position = UDim2.new(0,0,0.7,0)
hpBg.BackgroundColor3 = Color3.fromRGB(40,40,40)
hpBg.BorderSizePixel = 0

local hpFill = Instance.new("Frame", hpBg)
hpFill.BackgroundColor3 = Color3.fromRGB(0,255,0)
hpFill.Size = UDim2.new(1,0,1,0)
hpFill.BorderSizePixel = 0

RunService.RenderStepped:Connect(function()
    local char = player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then TargetInfoFrame.Visible = false return end

    local tgt =
    (SilentAimPlayersEnabled and PlayerTarget)
    or (SilentAimNPCsEnabled and NPCTarget)
    if tgt then
        local hum = tgt:FindFirstChildWhichIsA("Humanoid")
        local r = getHRP(tgt)
        if hum and r then
            nameLbl.Text = tgt.Name
            distLbl.Text = "Distance: "..math.floor((r.Position - hrp.Position).Magnitude).." studs"
            hpFill.Size = UDim2.new(
                math.clamp(hum.Health / hum.MaxHealth, 0, 1),
                0,1,0
            )
            TargetInfoFrame.Visible = true
            return
        end
    end
    TargetInfoFrame.Visible = false
end)

return SilentAimModule
