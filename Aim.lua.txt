-- MERGED: SilentAimModule + LockCamera (uses SilentAim selection)
-- Lưu ý: Dán toàn bộ file này vào 1 LocalScript trong PlayerScripts / StarterPlayerScripts
-- Tác giả: merged by assistant (adapted from user's two scripts)

-- ===== SERVICES & BASIC =====
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local CollectionService = game:GetService("CollectionService")

local commE = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("CommE")
local MouseModule = RS:FindFirstChild("Mouse")

-- ========== SILENTAIM (kept mostly original) ==========
local SilentAimModule = {}

-- FLAGS / STATE
local SilentAimPlayersEnabled = true
local SilentAimNPCsEnabled = false
local UserWantsplayerAim = true
local UserWantsNPCAim = false
local PredictionEnabled = true
local HighlightEnabled = false
local AutoKen = false
local ZSkillorM1 = false
local autoKenRunning = false

local renderConnection = nil
local currentTool = nil
local playersaimbot = nil
local PlayersPosition = nil
local NPCaimbot = nil
local NPCPosition = nil
local currentHighlight = nil
local currentTargetType = nil
local Selectedplayer = nil

-- PIN / IGNORE SYSTEM
local PinnedPlayer = nil        -- Player object
local PinnedPlayerName = nil    -- stored name to repin after death/respawn
local IgnoredPlayers = {}       -- [playerName] = true

-- TARGET INFO
local PlayerTarget = nil
local NPCTarget = nil

-- PREDICTION VARS
local LastVelocity = {}
local LastPredictedPos = {}
local LastVelSamples = {}
local VELOCITY_SAMPLE_COUNT = 4
local AIM_SMOOTHNESS = 0.4
local PROJECTILE_SPEED = 120
local ENABLE_PROJECTILE_LEAD = false
local ENABLE_GRAVITY_COMP = false
local BaseHybridPrediction = 0.025
local SpeedFactor = 0.0015
local DistanceFactor = 0.000375
local MaxHybridPrediction = 0.35
local BasePrediction = 0.05
local MinPrediction = 0.01
local MaxPrediction = 0.35
local LastPos = {}
local LastTime = {}
local LastAcceleration = {}

local MAX_AIM_DISTANCE = 800
local LOW_HP_PRIORITY_DISTANCE = 200

local CAMERA_PITCH_LIMIT = 75
local AimDisabledByPitch = false

-- UTIL / PREDICTION
local function pushVelocitySample(hrp, vel)
    if not LastVelSamples[hrp] then LastVelSamples[hrp] = {} end
    local t = LastVelSamples[hrp]
    table.insert(t, 1, vel)
    while #t > VELOCITY_SAMPLE_COUNT do table.remove(t) end
end

local function averageVelocity(hrp, currentVel)
    pushVelocitySample(hrp, currentVel)
    local t = LastVelSamples[hrp]
    if not t or #t == 0 then return currentVel end
    local sum = Vector3.new(0,0,0)
    for _, v in ipairs(t) do sum = sum + v end
    return sum / #t
end

local function isNearGround(hrp)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {hrp.Parent, workspace:FindFirstChild("Enemies") or workspace}
	local rayResult = Workspace:Raycast(hrp.Position, Vector3.new(0, -10, 0), rayParams)
	return rayResult ~= nil
end

local function getHybridPrediction(hrp, velocity)
	local camPos = Camera.CFrame.Position
	local distance = (hrp.Position - camPos).Magnitude
	local speed = velocity.Magnitude
	local distanceScale = math.clamp(distance / 110, 0.25, 1)
	local prediction =
		(BaseHybridPrediction * distanceScale) +
		(speed * SpeedFactor) +
    	(distance * DistanceFactor)
	return math.clamp(prediction, MinPrediction, MaxHybridPrediction)
end

local function getHRP(model)
	if not model or not model:FindFirstChild("HumanoidRootPart") then return nil end
	return model.HumanoidRootPart
end

local function getPredictedPosition(hrp)
    if not hrp then return nil end
    local humanoid = hrp.Parent:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        LastPredictedPos[hrp] = hrp.Position
        return hrp.Position
    end

    local rawVel = hrp.AssemblyLinearVelocity or Vector3.new(0,0,0)

    -- Anti-zigzag smoothing
    if LastVelocity[hrp] then
        local lastVel = LastVelocity[hrp]
        if lastVel.Magnitude > 0 and rawVel.Magnitude > 0 then
            local dot = rawVel.Unit:Dot(lastVel.Unit)
            if dot < 0.25 then
                local damp = math.clamp((dot + 1) / 2, 0.35, 1)
                rawVel = rawVel * damp
            end
        end
    end

    local vel = averageVelocity(hrp, rawVel)
    LastVelocity[hrp] = vel

    local speed = vel.Magnitude
    local moveDirMag = humanoid.MoveDirection.Magnitude
    if not PredictionEnabled or (speed < 5 and moveDirMag < 0.085) then
        LastPredictedPos[hrp] = hrp.Position
        return hrp.Position
    end

    if isNearGround(hrp) then
        vel = Vector3.new(vel.X, 0, vel.Z)
    end

    local distance = (hrp.Position - Camera.CFrame.Position).Magnitude
    local predicted
    if ENABLE_PROJECTILE_LEAD then
        local travelTime = distance / PROJECTILE_SPEED
        predicted = hrp.Position + vel * travelTime
        if ENABLE_GRAVITY_COMP then
            local g = workspace.Gravity or 196.2
            predicted += Vector3.new(0, 0.5 * g * travelTime * travelTime, 0)
        end
    else
        local predictionAmount = getHybridPrediction(hrp, vel)
        predicted = hrp.Position + vel * predictionAmount
    end

    local head = hrp.Parent:FindFirstChild("Head")
    if head then
        predicted += Vector3.new(0, head.Size.Y * 0.25, 0)
    end

    local lastPred = LastPredictedPos[hrp] or hrp.Position
    local alpha = math.clamp(1 - AIM_SMOOTHNESS, 0.05, 1)
    local finalPred = lastPred:Lerp(predicted, alpha)

    LastPredictedPos[hrp] = finalPred
    return finalPred
end

-- TEAM / ALLY CHECK (reused by Lock)
local function isAllyWithMe(targetplayer)
	local myGui = player:FindFirstChild("PlayerGui")
	if not myGui then return false end

	local scrolling = myGui:FindFirstChild("Main")
		and myGui.Main:FindFirstChild("Allies")
		and myGui.Main.Allies:FindFirstChild("Container")
		and myGui.Main.Allies.Container:FindFirstChild("Allies")
		and myGui.Main.Allies.Container.Allies:FindFirstChild("ScrollingFrame")

	if scrolling then
		for _, frame in pairs(scrolling:GetDescendants()) do
			if frame:IsA("ImageButton") and frame.Name == targetplayer.Name then
				return true
			end
		end
	end

	return false
end

local function isEnemy(targetplayer)
	if not targetplayer or targetplayer == player then
		return false
	end

	local myTeam = player.Team
	local targetTeam = targetplayer.Team

	if myTeam and targetTeam then
		if myTeam.Name == "Pirates" and targetTeam.Name == "Marines" then
			return true
		elseif myTeam.Name == "Marines" and targetTeam.Name == "Pirates" then
			return true
		end

		if myTeam.Name == "Pirates" and targetTeam.Name == "Pirates" then
			if isAllyWithMe(targetplayer) then
				return false -- ally, not enemy
			end
			return true
		end

		if myTeam.Name == "Marines" and targetTeam.Name == "Marines" then
			return false
		end
	end

	return true
end

-- ===== LOW HP PRIORITY & CLOSEST PLAYER (used by Lock)
local function getLowestHPPlayerInRange(lpHRP, range)
    local bestTarget = nil
    local bestHpRatio = math.huge
    local bestDist = math.huge

    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= player
        and not IgnoredPlayers[pl.Name]
        and isEnemy(pl)
        and pl.Character then

            local hrp = getHRP(pl.Character)
            local hum = pl.Character:FindFirstChildWhichIsA("Humanoid")

            if hrp and hum and hum.Health > 0 then
                local dist = (hrp.Position - lpHRP.Position).Magnitude
                if dist <= range then
                    local ratio = hum.Health / (hum.MaxHealth > 0 and hum.MaxHealth or 1)

                    if ratio < bestHpRatio then
                        bestHpRatio = ratio
                        bestDist = dist
                        bestTarget = pl
                    elseif math.abs(ratio - bestHpRatio) < 0.01 then
                        if dist < bestDist then
                            bestDist = dist
                            bestTarget = pl
                        end
                    end
                end
            end
        end
    end

    return bestTarget
end

local function getClosestplayer(lpHRP)
	-- PIN priority
	if PinnedPlayer then
		if not IgnoredPlayers[PinnedPlayer.Name]
		and PinnedPlayer.Character then

			local hum = PinnedPlayer.Character:FindFirstChildWhichIsA("Humanoid")
			local hrp = getHRP(PinnedPlayer.Character)

			if hum and hum.Health > 0 and hrp then
				if (hrp.Position - lpHRP.Position).Magnitude <= MAX_AIM_DISTANCE then
					return PinnedPlayer
				else
					-- pinned outside range
					return nil
				end
			end
		end

		-- invalid pin -> clear
		PinnedPlayer = nil
	end

	-- LOW HP priority
	local lowHpTarget = getLowestHPPlayerInRange(lpHRP, LOW_HP_PRIORITY_DISTANCE)
	if lowHpTarget and (lowHpTarget.Character and getHRP(lowHpTarget.Character)) and (getHRP(lowHpTarget.Character).Position - lpHRP.Position).Magnitude <= MAX_AIM_DISTANCE then
	    return lowHpTarget
	end

	-- otherwise nearest
	local closest = nil
	local closestDist = math.huge

	for _, pl in ipairs(Players:GetPlayers()) do
	    if pl ~= player
	    and not IgnoredPlayers[pl.Name]
	    and isEnemy(pl)
	    and pl.Character then

	        local hrp = getHRP(pl.Character)
	        local hum = pl.Character:FindFirstChildWhichIsA("Humanoid")

	        if hrp and hum and hum.Health > 0 and (hrp.Position - lpHRP.Position).Magnitude <= MAX_AIM_DISTANCE then
	            local dist = (hrp.Position - lpHRP.Position).Magnitude
	            if dist < closestDist then
	                closestDist = dist
	                closest = pl
	            end
	        end
	    end
	end

	return closest
end

-- HIGHLIGHT
local function applyHighlight(targetModel, targetType)
    if not HighlightEnabled then return end
    if not targetModel then return end
    if currentHighlight and currentHighlight.Adornee == targetModel then return end

    if currentHighlight then  
        currentHighlight:Destroy()  
        currentHighlight = nil  
        currentTargetType = nil  
    end  

    local hl = Instance.new("Highlight")  
    hl.FillColor = Color3.fromRGB(255, 255, 0)  
    hl.OutlineColor = Color3.fromRGB(255, 255, 0)  
    hl.FillTransparency = 0.5  
    hl.OutlineTransparency = 0  
    hl.Adornee = targetModel  
    hl.Parent = targetModel  
    currentHighlight = hl  
    currentTargetType = targetType
end

local function clearHighlight()
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
        currentTargetType = nil
    end
end

-- Render loop (tracks selected aims)
local function startRenderLoop()
    if renderConnection then return end

    renderConnection = RunService.RenderStepped:Connect(function()
        local lpChar = player.Character
        if not lpChar then return end
        local lpHRP = lpChar:FindFirstChild("HumanoidRootPart")
        if not lpHRP then return end

        -- camera pitch check
        local cam = Camera or workspace.CurrentCamera
        if cam and cam.CFrame then
            local lookY = cam.CFrame.LookVector.Y or 0
            local pitchDeg = math.deg(math.asin(lookY))
            if pitchDeg > CAMERA_PITCH_LIMIT then
                AimDisabledByPitch = true
                playersaimbot, PlayersPosition, PlayerTarget = nil, nil, nil
                NPCaimbot, NPCPosition, NPCTarget = nil, nil, nil
                clearHighlight()
                return
            else
                AimDisabledByPitch = false
            end
        end

        if not SilentAimPlayersEnabled and not SilentAimNPCsEnabled then
            return
        end

        local targetModel = nil
        local lookTargetPos = nil

        if SilentAimPlayersEnabled then
            local targetplayer = getClosestplayer(lpHRP)
            if targetplayer and targetplayer ~= player and targetplayer.Character then
                playersaimbot = targetplayer.Name
                PlayerTarget = targetplayer.Character
                local hrp = getHRP(targetplayer.Character)
                PlayersPosition = getPredictedPosition(hrp)
                lookTargetPos = PlayersPosition
                targetModel = targetplayer.Character
                applyHighlight(targetModel, "player")
            else
                playersaimbot, PlayersPosition = nil, nil
                PlayerTarget = nil
            end
        elseif currentTargetType == "player" then
            playersaimbot, PlayersPosition = nil, nil
            clearHighlight()
        end

        if SilentAimNPCsEnabled then
            local enemiesFolder = workspace:FindFirstChild("Enemies")
            local closestNPC = nil
            if enemiesFolder then
                local minD = math.huge
                for _, npc in ipairs(enemiesFolder:GetChildren()) do
                    if npc:IsA("Model") then
                        local hrp = getHRP(npc)
                        local hum = npc:FindFirstChildWhichIsA("Humanoid")
                        if hrp and hum and hum.Health > 0 then
                            local d = (hrp.Position - lpHRP.Position).Magnitude
                            if d < minD and d <= MAX_AIM_DISTANCE then
                                minD = d
                                closestNPC = npc
                            end
                        end
                    end
                end
            end
            if closestNPC then
                NPCaimbot = closestNPC.Name
                NPCTarget = closestNPC
                local hrp = getHRP(closestNPC)
                NPCPosition = getPredictedPosition(hrp)
                lookTargetPos = NPCPosition
                if not targetModel then
                    targetModel = closestNPC
                    applyHighlight(targetModel, "NPC")
                end
            else
                NPCaimbot, NPCPosition = nil, nil
            end
        elseif currentTargetType == "NPC" then
            NPCaimbot, NPCPosition = nil, nil
            NPCTarget = nil
            clearHighlight()
        end
    end)
end

local function stopRenderLoop()
    if renderConnection then
        renderConnection:Disconnect()
        renderConnection = nil
    end
end

-- MouseModule hooking for skills (kept)
local Mouse = nil
if MouseModule and typeof(MouseModule) == "Instance" then
    local ok2, okResult = pcall(function() return require(MouseModule) end)
    if ok2 and okResult and type(okResult) == "table" then
        Mouse = okResult
    end
end

RunService.Heartbeat:Connect(function()
    if not ZSkillorM1 or (not SilentAimPlayersEnabled and not SilentAimNPCsEnabled) then return end
    if Mouse and (SilentAimPlayersEnabled or SilentAimNPCsEnabled) then
        local targetCFrame = nil
        if PlayersPosition then targetCFrame = CFrame.new(PlayersPosition)
        elseif NPCPosition then targetCFrame = CFrame.new(NPCPosition) end
        if targetCFrame then
            pcall(function()
                if type(Mouse) == "table" then
                    Mouse.Hit = targetCFrame
                    Mouse.Target = nil
                end
            end)
            if MouseModule then
                local ok, MouseData = pcall(require, MouseModule)
                if ok and type(MouseData) == "table" then
                    MouseData.Hit = targetCFrame
                    MouseData.Target = nil
                end
            end
        end
    end
end)

-- AutoKen (kept)
local function HasTag(tagName)
  local char = player.Character
  if (not char) then return false; end
  return CollectionService:HasTag(char, tagName);
end

local function startAutoKenLoop()
    if autoKenRunning then return end
    autoKenRunning = true

    task.spawn(function()
        while AutoKen do
            task.wait(0.1)
            if HasTag("Ken") then
                local playerGui = player:FindFirstChild("PlayerGui")
                if playerGui then
                    local kenButton = playerGui:FindFirstChild("MobileContextButtons")
                    and playerGui.MobileContextButtons.ContextButtonFrame:FindFirstChild("BoundActionKen")

                    if kenButton and kenButton:GetAttribute("Selected") ~= true then
                        kenButton:SetAttribute("Selected", true)
                    end
                end

                local observationManager = getrenv()._G.OM
                if observationManager and not observationManager.active then
                    observationManager.radius = 0
                    observationManager:setActive(true)
                    if commE then pcall(function() commE:FireServer("Ken", true) end) end
                end
            end
        end
        autoKenRunning = false
    end)
end

-- PIN / IGNORE functions + UI helpers (mini toggles)
-- (createMiniToggle from original kept if needed by caller; omitted for brevity)
-- We'll keep the core toggle functions and refresh logic used by Aim menu below.

local function togglePinPlayer(plr)
	if not plr then
		PinnedPlayer = nil
		PinnedPlayerName = nil
		return
	end
	if PinnedPlayer == plr then
		PinnedPlayer = nil
		PinnedPlayerName = nil
	else
		PinnedPlayer = plr
		PinnedPlayerName = plr.Name
	end
	Selectedplayer = nil
	-- refresh UI if present (refreshPlayerLists defined later)
	if refreshPlayerLists then pcall(refreshPlayerLists) end
end

local function toggleIgnorePlayer(name)
	IgnoredPlayers[name] = not IgnoredPlayers[name]
	if PinnedPlayer and PinnedPlayer.Name == name then
		-- if we ignored the pinned player, clear pin
		PinnedPlayer = nil
		PinnedPlayerName = nil
	end
	Selectedplayer = nil
	if refreshPlayerLists then pcall(refreshPlayerLists) end
end

-- Repin logic: when a player's character added, if PinnedPlayerName exists -> reassign PinnedPlayer
Players.PlayerAdded:Connect(function(pl)
    if PinnedPlayerName and pl.Name == PinnedPlayerName then
        PinnedPlayer = pl
    end
end)
Players.PlayerRemoving:Connect(function(pl)
    if PinnedPlayer and pl == PinnedPlayer then
        PinnedPlayer = nil
    end
end)
-- ensure repin on CharacterAdded
Players.PlayerAdded:Connect(function(pl)
    pl.CharacterAdded:Connect(function()
        if PinnedPlayerName and pl.Name == PinnedPlayerName then
            PinnedPlayer = pl
        end
    end)
end)

-- When a player's character respawns, if they match pinned name reassign
Players.PlayerAdded:Connect(function(pl)
    if PinnedPlayerName and pl.Name == PinnedPlayerName and pl.Character then
        PinnedPlayer = pl
    end
end)

-- ======== GUI FOR AIM (Target info, ESP, Aim menu) ========
-- Target Info UI
local AimGui = Instance.new("ScreenGui")
AimGui.Name = "SilentAimGUI"
AimGui.ResetOnSpawn = false
AimGui.Parent = player:WaitForChild("PlayerGui")
AimGui.DisplayOrder = 20 -- HIGHER -> will render above lock GUI

local TargetInfoFrame = Instance.new("Frame", AimGui)
TargetInfoFrame.Size = UDim2.new(0.26,0,0.095,0)
TargetInfoFrame.Position = UDim2.new(0.5,0,0.05,0)
TargetInfoFrame.AnchorPoint = Vector2.new(0.5,0)
TargetInfoFrame.BackgroundTransparency = 1
TargetInfoFrame.Visible = false

local nameLbl = Instance.new("TextLabel", TargetInfoFrame)
nameLbl.Size = UDim2.new(1,0,0.4,0)
nameLbl.BackgroundTransparency = 1
nameLbl.TextScaled = true
nameLbl.Font = Enum.Font.GothamBold
nameLbl.TextColor3 = Color3.new(1,1,1)

local distLbl = Instance.new("TextLabel", TargetInfoFrame)
distLbl.Size = UDim2.new(1,0,0.25,0)
distLbl.Position = UDim2.new(0,0,0.4,0)
distLbl.BackgroundTransparency = 1
distLbl.TextScaled = true
distLbl.Font = Enum.Font.Gotham
distLbl.TextColor3 = Color3.fromRGB(200,200,200)

local hpBg = Instance.new("Frame", TargetInfoFrame)
hpBg.Size = UDim2.new(1,0,0.2,0)
hpBg.Position = UDim2.new(0,0,0.7,0)
hpBg.BackgroundColor3 = Color3.fromRGB(40,40,40)
hpBg.BorderSizePixel = 0

local hpFill = Instance.new("Frame", hpBg)
hpFill.BackgroundColor3 = Color3.fromRGB(0,255,0)
hpFill.Size = UDim2.new(1,0,1,0)
hpFill.BorderSizePixel = 0

RunService.RenderStepped:Connect(function()
    local char = player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then TargetInfoFrame.Visible = false return end

    local tgt = (SilentAimPlayersEnabled and PlayerTarget) or (SilentAimNPCsEnabled and NPCTarget)
    if tgt then
        local hum = tgt:FindFirstChildWhichIsA("Humanoid")
        local r = getHRP(tgt)
        if hum and r then
            nameLbl.Text = tgt.Name
            distLbl.Text = "Distance: "..math.floor((r.Position - hrp.Position).Magnitude).." studs"
            hpFill.Size = UDim2.new(math.clamp(hum.Health / (hum.MaxHealth > 0 and hum.MaxHealth or 1), 0, 1), 0, 1, 0)
            TargetInfoFrame.Visible = true
            return
        end
    end
    TargetInfoFrame.Visible = false
end)

-- ESP diamond (kept)
local EspGui = Instance.new("ScreenGui", player.PlayerGui)
EspGui.Name = "TargetDiamondESP"
EspGui.ResetOnSpawn = false
EspGui.IgnoreGuiInset = true
EspGui.DisplayOrder = 21 -- render above lock also

local diamond = Instance.new("Frame", EspGui)
diamond.Size = UDim2.new(0,14,0,14)
diamond.AnchorPoint = Vector2.new(0.5,0.5)
diamond.BackgroundColor3 = Color3.fromRGB(220,40,40)
diamond.BorderSizePixel = 0
diamond.Rotation = 45
diamond.Visible = false

local stroke = Instance.new("UIStroke", diamond)
stroke.Thickness = 1.5
stroke.Color = Color3.fromRGB(0,0,0)

local distText = Instance.new("TextLabel", EspGui)
distText.Size = UDim2.new(0,60,0,16)
distText.AnchorPoint = Vector2.new(0.5,0)
distText.BackgroundTransparency = 1
distText.TextScaled = true
distText.Font = Enum.Font.GothamBold
distText.TextColor3 = Color3.new(1,1,1)
distText.TextStrokeTransparency = 0.3
distText.Visible = false

RunService.RenderStepped:Connect(function()
    local char = player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then
        diamond.Visible = false
        distText.Visible = false
        return
    end

    local target = (SilentAimPlayersEnabled and PlayerTarget) or (SilentAimNPCsEnabled and NPCTarget)
    if not target then
        diamond.Visible = false
        distText.Visible = false
        return
    end

    local targetHRP = getHRP(target)
    if not targetHRP then return end

    local aimWorldPos = targetHRP.Position + Vector3.new(0, targetHRP.Size.Y * 0.85, 0)
    local cam = workspace.CurrentCamera
    local viewSize = cam.ViewportSize
    local screenCenter = viewSize / 2

    local screenPoint, onScreen = cam:WorldToViewportPoint(aimWorldPos)
    local pos2D = Vector2.new(screenPoint.X, screenPoint.Y)

    local finalPos
    local isBehind = screenPoint.Z < 0

    if onScreen and not isBehind then
        finalPos = pos2D
    else
        local rawPos = pos2D
        if isBehind then
            rawPos = screenCenter + (screenCenter - pos2D).Unit * 5000
        end

        local delta = rawPos - screenCenter
        local padding = 20
        local safeX = (viewSize.X / 2) - padding
        local safeY = (viewSize.Y / 2) - padding
        local scale = math.min(math.abs(safeX / (delta.X ~= 0 and delta.X or 0.0001)), math.abs(safeY / (delta.Y ~= 0 and delta.Y or 0.0001)))
        finalPos = screenCenter + delta * scale
    end

    diamond.Position = UDim2.fromOffset(finalPos.X, finalPos.Y)
    local textOffsetY = 12
    if finalPos.Y > (viewSize.Y - 40) then
        textOffsetY = -28
    end

    distText.Position = UDim2.fromOffset(finalPos.X, finalPos.Y + textOffsetY)
    distText.Text = math.floor((aimWorldPos - hrp.Position).Magnitude) .. " m"
    diamond.Visible = true
    distText.Visible = true
end)

-- Auto start render loop in case aim is enabled on spawn
task.spawn(function()
    task.wait(0.1)
    if SilentAimPlayersEnabled or SilentAimNPCsEnabled then
        startRenderLoop()
    end
end)

-- ========= PUBLIC API FOR SILENTAIM (kept) =========
function SilentAimModule:SetAutoKen(state) AutoKen = state if state then startAutoKenLoop() end end
function SilentAimModule:SetZSkillorM1(state) ZSkillorM1 = state end
function SilentAimModule:Pause() SilentAimPlayersEnabled = false SilentAimNPCsEnabled = false end
function SilentAimModule:Restore() SilentAimPlayersEnabled = UserWantsplayerAim SilentAimNPCsEnabled = UserWantsNPCAim end
function SilentAimModule:IsplayerAimEnabled() return SilentAimPlayersEnabled end
function SilentAimModule:IsNPCAimEnabled() return SilentAimNPCsEnabled end
function SilentAimModule:SetDistanceLimit(num) if typeof(num) == "number" then MAX_AIM_DISTANCE = num end end
function SilentAimModule:SetSelectedPlayer(playerName)
    if not playerName or playerName == "" then Selectedplayer = nil; PinnedPlayer = nil; PinnedPlayerName = nil; return end
    local found = Players:FindFirstChild(playerName)
    if found then Selectedplayer = found; togglePinPlayer(found) end
end
function SilentAimModule:GetSelectedPlayer() return Selectedplayer and Selectedplayer.Name or (PinnedPlayerName or "None") end
function SilentAimModule:SetPrediction(state) PredictionEnabled = state end
function SilentAimModule:SetHighlight(state) HighlightEnabled = state if not state then clearHighlight() end end
function SilentAimModule:IsHighlightEnabled() return HighlightEnabled end
function SilentAimModule:SetPlayerSilentAim(state) UserWantsplayerAim = state; SilentAimPlayersEnabled = state; if state then startRenderLoop() else if not SilentAimNPCsEnabled then stopRenderLoop() end end end
function SilentAimModule:SetNPCSilentAim(state) UserWantsNPCAim = state; SilentAimNPCsEnabled = state; if state then startRenderLoop() else if not SilentAimPlayersEnabled then stopRenderLoop() end end end
function SilentAimModule:SetAimSmoothness(val) if type(val) == "number" then AIM_SMOOTHNESS = math.clamp(val, 0, 0.95) end end
function SilentAimModule:SetVelocitySampleCount(n) if type(n) == "number" and n >= 1 then VELOCITY_SAMPLE_COUNT = math.floor(n) end end
function SilentAimModule:SetProjectileSpeed(spd) if type(spd) == "number" then PROJECTILE_SPEED = spd end end
function SilentAimModule:EnableProjectileLead(state) ENABLE_PROJECTILE_LEAD = not not state end
function SilentAimModule:EnableGravityCompensation(state) ENABLE_GRAVITY_COMP = not not state end
-- End SilentAimModule

-- ======= LOCK CAMERA SECTION (modified to use SilentAim selection) =======

-- lock config
local LOCK_RANGE = 195
local MIN_DISTANCE = 8
local LOCK_TIME = 5
local CAM_BEHIND_DIST = 4.75
local CAM_HEIGHT = 0
local CAM_LOOK_OFFSET = Vector3.new(0, 0.4, 0)
local requireFirstClose = false
local FIRST_LOCK_MAX_DIST = 170

-- fixed hitbox
local HITBOX_FIXED_SIZE = Vector3.new(6,6,6)
local HITBOX_VISIBLE_TRANSPARENCY = 0.8
local HITBOX_COLOR = "Bright red"
local HITBOX_MATERIAL = Enum.Material.Neon

-- search tuning
local SEARCH_INTERVAL = 0.15
local nextSearchTime = 0

-- lock state
local comboBusy = false
local locking = false
local lockConnection = nil
local oldCameraType = nil
local oldCameraSubject = nil
local currentTarget = nil
local startTime = nil
local lastLockedCharVar = nil
local lockReferenceDir = nil
local hitboxProxies = {}
local charAddedConn = nil
local deathConn = nil
local healthConn = nil
local lastHealth = nil

-- Lock GUI (separate, lower display order than Aim GUI)
local lockGui = Instance.new("ScreenGui")
lockGui.Name = "LockCameraGUI"
lockGui.ResetOnSpawn = false
lockGui.Parent = player:WaitForChild("PlayerGui")
lockGui.DisplayOrder = 5 -- lower than AimGui so Aim UI draws above

local lockButton = Instance.new("TextButton")
lockButton.Size = UDim2.fromOffset(80,36)
lockButton.Position = UDim2.fromOffset(10,10)
lockButton.Text = "LOCK : OFF"
lockButton.BackgroundColor3 = Color3.fromRGB(30,30,30)
lockButton.TextColor3 = Color3.new(1,1,1)
lockButton.Font = Enum.Font.SourceSansBold
lockButton.TextSize = 16
lockButton.BorderSizePixel = 0
lockButton.AutoButtonColor = false
lockButton.Parent = lockGui

local function pressKey(keycode)
	pcall(function()
		VirtualInputManager:SendKeyEvent(true, keycode, false, game)
		task.wait(0.05)
		VirtualInputManager:SendKeyEvent(false, keycode, false, game)
	end)
end

local function pauseLock()
	currentTarget = nil
	startTime = nil
	nextSearchTime = tick() + 0.01
end

local function equipToolByName(toolName)
	if not player.Character then return end
	local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end
	for _, tool in ipairs(player.Backpack:GetChildren()) do
		if tool:IsA("Tool") and tool.Name == toolName then
			humanoid:EquipTool(tool)
			return
		end
	end
end

local function handleMinDistanceSkill()
	if comboBusy then return end
	if not player.Character then return end

	local tool = player.Character:FindFirstChildOfClass("Tool")
	if not tool then return end

	local name = tool.Name
	comboBusy = true
	-- keep original combos (trimmed for brevity)
	if name == "Sanguine Art" then
		pressKey(Enum.KeyCode.Z)
		task.delay(0, function() comboBusy = false end)
	elseif name == "Kitsune-Kitsune" then
		pressKey(Enum.KeyCode.C)
		task.wait(0.12)
		equipToolByName("Yama")
		task.wait(0.08)
		pressKey(Enum.KeyCode.X)
		pressKey(Enum.KeyCode.X)
		task.wait(0.1)
		equipToolByName("Sanguine Art")
		task.wait(0.2)
		pressKey(Enum.KeyCode.Z)
		pressKey(Enum.KeyCode.Z)
		task.delay(0.3, function() comboBusy = false end)
	elseif name == "Yama" then
		pressKey(Enum.KeyCode.X)
		task.wait(0.35)
		equipToolByName("Skull Guitar")
		task.wait(0.08)
		pressKey(Enum.KeyCode.X)
		task.delay(0.3, function() comboBusy = false end)
	elseif name == "Skull Guitar" then
		pressKey(Enum.KeyCode.X)
		task.delay(0, function() comboBusy = false end)
	else
		comboBusy = false
	end
end

local function getMyHRP()
	if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		return player.Character.HumanoidRootPart
	end
	return nil
end

local function safeRestoreCamera()
	if not Camera then return end
	if oldCameraType then
		pcall(function() Camera.CameraType = oldCameraType end)
	end
	if oldCameraSubject then
		local ok = pcall(function() Camera.CameraSubject = oldCameraSubject end)
		if not ok then
			local hum = nil
			if player.Character then hum = player.Character:FindFirstChildOfClass("Humanoid") end
			if hum then pcall(function() Camera.CameraSubject = hum end) end
		end
	end
end

local function getLocalCameraHorizontalDir()
	if not Camera or not Camera.CFrame then return Vector3.new(0,0,-1) end
	local lv = Camera.CFrame.LookVector
	local dir = Vector3.new(lv.X, 0, lv.Z)
	if dir.Magnitude > 0 then return dir.Unit else return Vector3.new(0,0,-1) end
end

-- hitbox proxy
local function createHitboxProxyForCharacter(char)
	if not char or not char.Parent then return end
	if hitboxProxies[char] then return end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local p = Instance.new("Part")
	p.Name = "LockHitboxProxy"
	p.Size = HITBOX_FIXED_SIZE
	p.Transparency = HITBOX_VISIBLE_TRANSPARENCY
	p.BrickColor = BrickColor.new(HITBOX_COLOR)
	p.Material = HITBOX_MATERIAL
	p.CanCollide = false
	p.Anchored = false
	p.Massless = true
	p.CastShadow = false
	p.Parent = char
	p.CFrame = hrp.CFrame

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = p
	weld.Part1 = hrp
	weld.Parent = p

	hitboxProxies[char] = { proxy = p }
end

local function destroyHitboxProxyForCharacter(char)
	if not char then return end
	local data = hitboxProxies[char]
	if data and data.proxy and data.proxy.Parent then
		pcall(function() data.proxy:Destroy() end)
	end
	hitboxProxies[char] = nil
end

-- stop lock
local function stopLock()
	if not locking then return end
	if currentTarget and currentTarget.Parent then
		destroyHitboxProxyForCharacter(currentTarget)
	end
	if lastLockedCharVar and lastLockedCharVar.Parent then
		destroyHitboxProxyForCharacter(lastLockedCharVar)
	end

	locking = false
	lockButton.Text = "LOCK : OFF"
	lockButton.BackgroundColor3 = Color3.fromRGB(30,30,30)

	if lockConnection then
		lockConnection:Disconnect()
		lockConnection = nil
	end

	safeRestoreCamera()

	lockReferenceDir = nil
	currentTarget = nil
	startTime = nil
	lastLockedCharVar = nil
end

-- health/connect
local function connectHealthToHumanoid(humanoid)
	if healthConn then healthConn:Disconnect(); healthConn = nil end
	local ok, h = pcall(function() return humanoid.Health end)
	if ok then lastHealth = h else lastHealth = nil end

	healthConn = humanoid.HealthChanged:Connect(function(newHealth)
		if lastHealth == nil then lastHealth = newHealth; return end
		if locking and newHealth < lastHealth then
			-- took damage while locking -> stop
			stopLock()
		end
		lastHealth = newHealth
	end)
end

local function onLocalCharacterAdded(char)
	if deathConn then deathConn:Disconnect(); deathConn = nil end
	lastHealth = nil
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if humanoid then
		deathConn = humanoid.Died:Connect(function()
			stopLock()
		end)
		connectHealthToHumanoid(humanoid)
	end
end

if player.Character then onLocalCharacterAdded(player.Character) end
player.CharacterAdded:Connect(onLocalCharacterAdded)

-- START LOCK (uses getClosestplayer from SilentAim)
local function startLock()
	if locking then return end

	oldCameraType = Camera and Camera.CameraType or Enum.CameraType.Custom
	oldCameraSubject = Camera and Camera.CameraSubject or nil

	-- use SilentAim selection to check nearest player (we'll provide dist)
	local lpHRP = getMyHRP()
	local chosenPl = nil
	local chosenDist = math.huge
	if lpHRP then
	    local found = getClosestplayer(lpHRP)
	    if found and found.Character and getHRP(found.Character) then
	        chosenPl = found.Character
	        chosenDist = (getHRP(found.Character).Position - lpHRP.Position).Magnitude
	    end
	end

	if not chosenPl then
		requireFirstClose = true
	else
		requireFirstClose = false
	end

	locking = true
	lockButton.Text = "LOCK : ON"
	lockButton.BackgroundColor3 = Color3.fromRGB(160,60,60)

	startTime = nil
	lockReferenceDir = nil

	if player.Character then
		local hum = player.Character:FindFirstChildOfClass("Humanoid")
		if hum then
			lastHealth = hum.Health
			if not healthConn then connectHealthToHumanoid(hum) end
		end
	end

	nextSearchTime = 0

	lockConnection = RunService.RenderStepped:Connect(function()
		if not locking then return end

		local myHRP = getMyHRP()
		if not myHRP then stopLock(); return end

		-- if no currentTarget, do periodic search (use SilentAim's getClosestplayer)
		if not currentTarget then
			if tick() >= nextSearchTime then
				nextSearchTime = tick() + SEARCH_INTERVAL
				local enemyPl = getClosestplayer(myHRP)
				if enemyPl and enemyPl.Character and getHRP(enemyPl.Character) then
					local dist = (getHRP(enemyPl.Character).Position - myHRP.Position).Magnitude
					if requireFirstClose then
						if dist <= FIRST_LOCK_MAX_DIST then
							currentTarget = enemyPl.Character
							lastLockedCharVar = currentTarget
							requireFirstClose = false
							if LOCK_TIME and LOCK_TIME > 0 and LOCK_TIME < math.huge then startTime = tick() end
							lockReferenceDir = getLocalCameraHorizontalDir()
							createHitboxProxyForCharacter(currentTarget)
						end
					else
						currentTarget = enemyPl.Character
						lastLockedCharVar = currentTarget
						if LOCK_TIME and LOCK_TIME > 0 and LOCK_TIME < math.huge then startTime = tick() end
						lockReferenceDir = getLocalCameraHorizontalDir()
						createHitboxProxyForCharacter(currentTarget)
					end
				end
			end
			return
		end

		-- validate current target
		if not currentTarget.Parent then
			destroyHitboxProxyForCharacter(currentTarget)
			lastLockedCharVar = currentTarget
			stopLock()
			return
		end
		local targetHRP = currentTarget:FindFirstChild("HumanoidRootPart")
		local targetHum = currentTarget:FindFirstChildOfClass("Humanoid")
		if not targetHRP or not targetHum or targetHum.Health <= 0 then
			destroyHitboxProxyForCharacter(currentTarget)
			lastLockedCharVar = currentTarget
			stopLock()
			return
		end

		-- distance check
		local d = (targetHRP.Position - myHRP.Position).Magnitude
		if d > LOCK_RANGE then
			destroyHitboxProxyForCharacter(currentTarget)
			pauseLock()
			return
		end

		if d <= MIN_DISTANCE then
			handleMinDistanceSkill()
			destroyHitboxProxyForCharacter(currentTarget)
			stopLock()
			return
		end

		-- camera follow
		if Camera then
			if Camera.CameraType ~= Enum.CameraType.Scriptable then
				pcall(function() Camera.CameraType = Enum.CameraType.Scriptable end)
			end
			local dir = lockReferenceDir or getLocalCameraHorizontalDir()
			local behindPos = targetHRP.Position - (dir * CAM_BEHIND_DIST) + Vector3.new(0, CAM_HEIGHT, 0)
			local lookAt = targetHRP.Position + CAM_LOOK_OFFSET
			Camera.CFrame = CFrame.new(behindPos, lookAt)
		end

		-- timeout
		if startTime and LOCK_TIME and LOCK_TIME > 0 and tick() - startTime >= LOCK_TIME then
			lastLockedCharVar = currentTarget
			stopLock()
			return
		end
	end)
end

lockButton.MouseButton1Click:Connect(function()
	if locking then stopLock() else startLock() end
end)

-- cleanup function
local function cleanup()
	for char, _ in pairs(hitboxProxies) do destroyHitboxProxyForCharacter(char) end
	if lockConnection then lockConnection:Disconnect(); lockConnection = nil end
	if charAddedConn then charAddedConn:Disconnect(); charAddedConn = nil end
	if deathConn then deathConn:Disconnect(); deathConn = nil end
	if healthConn then healthConn:Disconnect(); healthConn = nil end
	lastHealth = nil
	stopLock()
	stopRenderLoop()
end

player.AncestryChanged:Connect(function()
	if not player:IsDescendantOf(game) then cleanup() end
end)

-- expose module on player for debug if needed
pcall(function() player:SetAttribute("SilentAimLoaded", true) end)
_G.SilentAimModule = SilentAimModule -- optional global for quick access

-- End of merged script
